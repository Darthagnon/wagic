# Important note:
# Macros are *global*, it doesn't matter where they are defined
# Macro names are case insensitive, and the replacement algorithm does an exact match inside a string
# it means that if you have a macro named MACRO and a macro named MACRO2, you'll run into trouble because MACRO2 will match MACRO
# Because of that, you need to use a unique delimiter at the beginning and the end of a macro, I personally use "__"
#
# Limitations: parameter inside macro must not contain "()"

# Standard Cycling
#AUTO_DEFINE __CYCLING__($cost) $cost{cycle}:name(cycling) draw:1

# Basic Landcycling
#AUTO_DEFINE __BASIC_LANDCYCLING__($cost) $cost{cycle}:name(basic landcycling) moveTo(myhand) target(land[basic]|mylibrary)

# Dies, Evergreen
#AUTO_DEFINE _DIES_ @movedTo(this|graveyard) from(battlefield):

# Training
#AUTO_DEFINE _TRAINING_ @combat(attacking) source(this) restriction{trainer}:name(Training) dotrain

# Partner
#AUTO_DEFINE _PARTNER_  may name(Put partner in hand) moveto(myhand) target(*[partname]|mylibrary)

# Goad
#AUTO_DEFINE _GOAD_ transforms((,newability[counter(0/0.1.Goaded) notrg],newability[this(counter{0/0.1.Goaded}>0) mustattack],newability[phaseaction[endofturn next once sourceinplay] counter(0/0.-hascntgoaded.Goaded) notrg])) forever

# Rebound
#AUTO_DEFINE _REBOUND_ if rebound then all(this|mystack) moveto(exile) and!( transforms((,newability[@rebounded:may name(Cast rebounded card) activate castcard(normal)])) forever )!

# Populate
#AUTO_DEFINE _POPULATE_ name(Populate) clone notAtarget(creature[token]|myBattlefield)

# Ferocious
#AUTO_DEFINE _FEROCIOUS_ if type(creature[power>=4]|myBattlefield)~morethan~0 then

# Attacking
#AUTO_DEFINE _ATTACKING_ @combat(attacking) source(this):

# Blocked
#AUTO_DEFINE _BLOCKED_ @combat(blocked,turnlimited) source(this):

# Heroic
#AUTO_DEFINE _HEROIC_ @targeted(this) from(*[instant;sorcery;aura]|myCastingzone):

# Rally
#AUTO_DEFINE _RALLY_ @movedTo(other ally|myBattlefield):

# Landfall
#AUTO_DEFINE _LANDFALL_ @movedTo(land|myBattlefield):

# Addendum
#AUTO_DEFINE _ADDENDUM_ if compare(restriction{assorcery}~morethan~0) then

# Constellation
#AUTO_DEFINE _CONSTELLATION_ @movedTo(enchantment|myBattlefield):

# Amass Zombies, Set WAR
#AUTO_DEFINE _AMASSZOMBIE1_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counter) name(Put 1/1 counter) notatarget(army|myBattlefield) transforms((Zombie,newability[counter(1/1)])) forever else name(Create Zombie Army) token(Zombie Army^Creature Zombie Army^0/0^black) and!( name(Put 1/1 counter) counter(1/1) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSZOMBIE2_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Zombie,newability[counter(1/1.2)])) forever else name(Create Zombie Army) token(Zombie Army^Creature Zombie Army^0/0^black) and!( name(Put 1/1 counters) counter(1/1.2) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSZOMBIE3_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Zombie,newability[counter(1/1.3)])) forever else name(Create Zombie Army) token(Zombie Army^Creature Zombie Army^0/0^black) and!( name(Put 1/1 counters) counter(1/1.3) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSZOMBIE4_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Zombie,newability[counter(1/1.4)])) forever else name(Create Zombie Army) token(Zombie Army^Creature Zombie Army^0/0^black) and!( name(Put 1/1 counters) counter(1/1.4) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSZOMBIE5_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Zombie,newability[counter(1/1.5)])) forever else name(Create Zombie Army) token(Zombie Army^Creature Zombie Army^0/0^black) and!( name(Put 1/1 counters) counter(1/1.5) notatarget(army|myBattlefield) )!

# Amass Orcs, Set LTR
#AUTO_DEFINE _AMASSORC1_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counter) name(Put 1/1 counter) notatarget(army|myBattlefield) transforms((Orc,newability[counter(1/1)])) forever else name(Create Orc Army) token(Orc Army) and!( name(Put 1/1 counter) counter(1/1) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSORC2_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Orc,newability[counter(1/1.2)])) forever else name(Create Orc Army) token(Orc Army) and!( name(Put 1/1 counters) counter(1/1.2) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSORC3_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Orc,newability[counter(1/1.3)])) forever else name(Create Orc Army) token(Orc Army) and!( name(Put 1/1 counters) counter(1/1.3) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSORC4_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Orc,newability[counter(1/1.4)])) forever else name(Create Orc Army) token(Orc Army) and!( name(Put 1/1 counters) counter(1/1.4) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSORC5_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Orc,newability[counter(1/1.5)])) forever else name(Create Orc Army) token(Orc Army) and!( name(Put 1/1 counters) counter(1/1.5) notatarget(army|myBattlefield) )!

# Amass Slivers, Set CMM
#AUTO_DEFINE _AMASSSLIVER1_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counter) name(Put 1/1 counter) notatarget(army|myBattlefield) transforms((Sliver,newability[counter(1/1)])) forever else name(Create Sliver Army) token(Sliver Army) and!( name(Put 1/1 counter) counter(1/1) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSSLIVER2_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Sliver,newability[counter(1/1.2)])) forever else name(Create Sliver Army) token(Sliver Army) and!( name(Put 1/1 counters) counter(1/1.2) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSSLIVER3_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Sliver,newability[counter(1/1.3)])) forever else name(Create Sliver Army) token(Sliver Army) and!( name(Put 1/1 counters) counter(1/1.3) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSSLIVER4_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Sliver,newability[counter(1/1.4)])) forever else name(Create Sliver Army) token(Sliver Army) and!( name(Put 1/1 counters) counter(1/1.4) notatarget(army|myBattlefield) )!
#AUTO_DEFINE _AMASSSLIVER5_ if type(army|mybattlefield)~morethan~0 then name(Put 1/1 counters) name(Put 1/1 counters) notatarget(army|myBattlefield) transforms((Sliver,newability[counter(1/1.5)])) forever else name(Create Sliver Army) token(Sliver Army) and!( name(Put 1/1 counters) counter(1/1.5) notatarget(army|myBattlefield) )!

# Scry, Evergreen
#AUTO_DEFINE _SCRY_($c) scry:$c scrycore delayed dontshow donothing scrycoreend scryend
#AUTO_DEFINE _SCRY1_ scry:1 scrycore delayed dontshow donothing scrycoreend scryend
#AUTO_DEFINE _SCRY2_ scry:2 scrycore delayed dontshow donothing scrycoreend scryend
#AUTO_DEFINE _SCRY3_ scry:3 scrycore delayed dontshow donothing scrycoreend scryend
#AUTO_DEFINE _SCRY4_ scry:4 scrycore delayed dontshow donothing scrycoreend scryend
#AUTO_DEFINE _SCRY5_ scry:5 scrycore delayed dontshow donothing scrycoreend scryend

# Fabricate
#AUTO_DEFINE _FABRICATE_($c) transforms((,newability[choice counter(1/1.$c)],newability[choice create(Servo:Artifact Creature Servo:1/1)*$c])) ueot

# Enrage
#AUTO_DEFINE _ENRAGE_ @damaged(this):

# Whenever you draw your second card each turn
#AUTO_DEFINE _SECOND_DRAW_ @drawof(player) restriction{compare(pdrewcount)~equalto~2}:

# Adapt
#AUTO_DEFINE _ADAPT_($c) name(Adapt $c) this(counter{1/1}<1) transforms((,newability[counter(1/1.$c)])) forever

# Battalion
#AUTO_DEFINE _BATTALION_ @combat(attacking) source(this) restriction{type(other creature[attacking]|myBattlefield)~morethan~1}:

# Champion, not implemented
#AUTO_DEFINE _CHAMPION_($Word) aslongas(other $word|myBattlefield) choice notAtarget(other $word|myBattlefield) (blink)forsrc oneshot

# Metalcraft, not implemented
#AUTO_DEFINE _METALCRAFT_ aslongas(artifact|mybattlefield) >2

# Echo, not implemented
#AUTO_DEFINE _ECHO_($cost) $cost[{$c};next upkeep] sacrifice

# Threshold, not implemented
#AUTO_DEFINE _THRESHOLD_ if type(*|mygraveyard)~morethan~6

# Splice onto Arcane, not implemented
#AUTO_DEFINE _SPLICEARCANE_ movedTo(*[Arcane]|myStack):may castcard(copied noevent) target(*[Arcane]|myHand)

# Ripple
#AUTO_DEFINE _RIPPLE_($c) autostack=if casted(this) then reveal:$c optionone name(Cast Card) target(<upto:$c>[share!name!]|reveal) moveTo(mylibrary) and!( becomes(tobecast) ueot )! optiononeend optiontwo name(put on bottom) target(<$c>*|reveal) bottomoflibrary optiontwoend afterrevealed all(tobecast|mylibrary) moveTo(myLibrary) and!( activate castcard(normal) )! afterrevealedend revealend

# Recover
#AUTO_DEFINE _RECOVER_($cost) @movedTo(creature|myGraveyard) from(Battlefield):may pay{$cost} name(Return to owner Hand) moveTo(ownerHand) all(this) donothing?moveTo(exile) all(this)

# Proliferate
#AUTO_DEFINE _PROLIFERATE_ name(Proliferate) notatarget(proliferation) proliferate

# Scavenge
#AUTO_DEFINE _SCAVENGE_($power) name(scavenge) counter(1/1.$power) target(creature) asSorcery

# Monstrosity, not implemented
#AUTO_DEFINE _MONSTROSITY_($cost,$c) name(Monstrosity) this(cantargetcard(*[-monstrous]) {$cost}:becomes(monstrous) forever && counter(1/1.$c)

# Outlast, not implemented
#AUTO_DEFINE _OUTLAST_($cost) {$cost}{$cost}:counter(1/1) all(this) asSorcery

# Investigate token, Shadows over Innistrad SOI
#AUTO_DEFINE _INVESTIGATE_ token(Clue)

# Ascend, Set XLN
#AUTO_DEFINE _ASCEND_ if type(City's Blessing|mybattlefield)~lessthan~1 then transforms((,newability[if type(*|mybattlefield)~morethan~9 then token(City's Blessing^notrigger)])) oneshot

# Effect with the City's blessing, Set XLN
#AUTO_DEFINE _CITY'S_BLESSING_ aslongas(City's Blessing|mybattlefield)>0

# Monarch
#AUTO_DEFINE _MONARCH_CONTROLLER_ if type(The Monarch|battlefield)~lessthan~1 then token(The Monarch^notrigger) else all(The Monarch|battlefield) moveto(mybattlefield) and!( transforms((,newability[becomesmonarch controller])) forever )!
#AUTO_DEFINE _MONARCH_OPPONENT_ if type(The Monarch|battlefield)~lessthan~1 then token(The Monarch^notrigger) opponent else all(The Monarch|battlefield) moveto(opponentbattlefield) and!( transforms((,newability[becomesmonarch controller])) forever )!

# Initiative
#AUTO_DEFINE _INITIATIVE_CONTROLLER_ if type(The Initiative|battlefield)~lessthan~1 then token(The Initiative^notrigger) else all(The Initiative|battlefield) moveto(mybattlefield) and!( transforms((,newability[takesinitiative controller])) forever )!
#AUTO_DEFINE _INITIATIVE_OPPONENT_ if type(The Initiative|battlefield)~lessthan~1 then token(The Initiative^notrigger) opponent else all(The Initiative|battlefield) moveto(opponentbattlefield) and!( transforms((,newability[takesinitiative controller])) forever )!

# The Ring Tempts
#AUTO_DEFINE _RINGTEMPTS_ if type(The Ring|mybattlefield)~morethan~0 then all(The Ring|mybattlefield) transforms((,newability[theringtempts:1 controller],newability[name(Chose a ring bearer) target(creature|mybattlefield) becomesringbearer])) oneshot else token(The Ring^notrigger) and!( theringtempts:1 controller and!( name(Choose a ring bearer) target(creature|myBattlefield) becomesringbearer )! )!

# Explore, not implemented
#AUTO_DEFINE _EXPLORE_ reveal:1 optionone if type(land|reveal)~lessthan~1 then transforms((,newability[counter(1/1)])) optiononeend optiontwo if type(land|reveal)~morethan~0 then name(move to Hand) target(<1>*|reveal) moveto(myHand) else transforms((,newability[Choice name(back to library) target(<1>*|reveal) moveto(mylibrary)],newability[Choice name(put into Graveyard) target(<1>*|reveal) moveto(myGraveyard)])) optiontwoend revealend limit:1

# Treasure token
#AUTO_DEFINE _TREASURE_ token(Treasure)

# Cast a historic spell
#AUTO_DEFINE _CASTHISTORIC_ @movedTo(*[artifact;legendary;saga]|mystack):

# Mentor, still not working with enhancements, pump effects
#AUTO_DEFINE _MENTOR_ @combat(attacking) source(this):counter(1/1) target(other creature[attacking;power<=pminus1minusend]|myBattlefield)

# Surveil, like scry, using parameters causes bugs so each value has to be indicated
#AUTO_DEFINE _SURVEIL1_ name(Surveil 1) reveal:psurveiloffsetplus1plusend optionone name(put in graveyard) target(<upto:psurveiloffsetplus1plusend>*|reveal) moveto(ownergraveyard) optiononeend optiontwo name(put in library) target(<psurveiloffsetplus1plusend>*|reveal) moveto(ownerlibrary) optiontwoend afterrevealed surveil afterrevealedend revealend

#AUTO_DEFINE _SURVEIL2_ name(Surveil 2) reveal:psurveiloffsetplus2plusend optionone name(put in graveyard) target(<upto:psurveiloffsetplus2plusend>*|reveal) moveto(ownergraveyard) optiononeend optiontwo name(put in library) target(<psurveiloffsetplus2plusend>*|reveal) moveto(ownerlibrary) optiontwoend afterrevealed surveil afterrevealedend revealend

#AUTO_DEFINE _SURVEIL3_ name(Surveil 3) reveal:psurveiloffsetplus3plusend optionone name(put in graveyard) target(<upto:psurveiloffsetplus3plusend>*|reveal) moveto(ownergraveyard) optiononeend optiontwo name(put in library) target(<psurveiloffsetplus3plusend>*|reveal) moveto(ownerlibrary) optiontwoend afterrevealed surveil afterrevealedend revealend

# Undergrowth, not implemented
#AUTO_DEFINE _UNDERGROWTH_ foreach(creature|myGraveyard)

# Afterlife
#AUTO_DEFINE _AFTERLIFETOKEN_ create(Spirit:Creature Spirit:1/1:white:black:flying)

# Riot
#AUTO_DEFINE _RIOT_ movedTo(this|myBattlefield):transforms((,newability[ability$! name(Choose counter or ability) choice name(Put a +1/+1 counter) counter(1/1) target(creature) _ choice name(Gains Haste) haste target(creature) forever !$ controller]))

# Learn
#AUTO_DEFINE _LEARN_ name(Learn) transforms((,newability[if type(*[lesson]|mysideboard)~morethan~0 then choice name(Put lesson in hand) name(Put lesson in hand) target(*[lesson]|mysideboard) moveto(myhand)],newability[if type(*|myhand)~morethan~0 then choice name(Discard and draw) name(Discard and draw) target(*|myhand) reject and!(draw:1)!],newability[if type(Retriever Phoenix|mygraveyard)~morethan~0 then choice name(Return a Retriever Phoenix) name(Return a Retriever Phoenix) target(Retriever Phoenix|mygraveyard) moveto(myBattlefield)],newability[choice name(Don't learn) donothing])) oneshot

# Spectacle, if an opponent lost life this turn 
#AUTO_DEFINE _SPECTACLE_ compare(oplifelost)~morethan~0

# Adventure
#AUTO_DEFINE _ADVENTURE_ name(Adventure) transforms((,newability[moveto(exile) and!( transforms((,newability[canplayfromexile forever])) forever )!])) forever

# Extort
#AUTO_DEFINE _EXTORT_ @movedto(*|mystack):pay({WB}) life:-1 opponent && life:1 controller

# Foretell
#AUTO_DEFINE _FORETELL_ {2}:name(Pay 2 and exile face-down) name(Pay 2 and exile face-down) doforetell myturnonly

# Loot (draw a card, discard a card.)
#AUTO_DEFINE _LOOT_ draw:1 && transforms((,newability[target(*|myhand) reject])) forever

# Unearth
#AUTO_DEFINE _UNEARTH_ name(Unearth) moveto(mybattlefield) and!( transforms((,newability[haste],newability[unearth],newability[exiledeath])) forever )! asSorcery

# Exile the top card of your library. you may play it this turn.
#AUTO_DEFINE __PLAY_TOP_FROM_EXILE__ moveto(exile) and!( transforms((,canplayfromexile)) ueot )! all(*[zpos=1]|mylibrary)

# Ward
#AUTO_DEFINE _WARD_($cost) @targeted(this) from(*|opponentzones):choice name(This spell costs $cost more) name(This spell costs $cost more) target(*|opponentzones) transforms((,newability[pay[[{$cost}]] name(pay $cost mana) donothing?fizzle])) oneshot

# Renown
#AUTO_DEFINE _RENOWN_($c) this(cantargetcard(*[-renown]) transforms((,newability[@combatdamaged(player) from(this):counter(1/1.$c) && becomes(renown) forever]))

# Exile card. Return it to the battlefield under its owner's control at the beginning of the next end step.
#AUTO_DEFINE _BLINK_UEOT_  moveto(exile) and!( transforms((,newability[phaseaction[endofturn once checkex] moveto(ownerbattlefield)])) forever )!

# Connives. (Draw a card, then discard a card. If you discarded a nonland card, put a +1/+1 counter on this creature.)
#AUTO_DEFINE _CONNIVES_ draw:1 && transforms((,newability[if type(*[-land]|myhand)~morethan~0 then choice name(Discard a nonland) name(Discard a nonland) target(*[-land]|myhand) reject && counter(1/1) all(this)],newability[if type(land|myhand)~morethan~0 then choice name(Discard a land) name(Discard a land) target(land|myhand) reject])) oneshot

# Eternalize 
#AUTO_DEFINE _ETERNALIZE_ name(Eternalize) clone and!( transforms((Zombie,removemc,setpower=4,settoughness=4,black)) forever )! assorcery

# Discard a card. If you do, draw a card
#AUTO_DEFINE _DISCARD&DRAW_ reject notatarget(*|myhand) and!(draw:1 controller)!

# Target creature deals damage equal to its power to target creature you don't control.
#AUTO_DEFINE _PUNCH_ transforms((,newability[dynamicability<!powerstrike!> target(creature|opponentbattlefield)])) oneshot

# Must be blocked this turn if able
#AUTO_DEFINE _MUST_BE_BLOCKD_ newability[@combat(attacking) source(this):ability$! notatarget(creature|myBattlefield) transforms((,newability[mustblock])) ueot!$ opponent]

# Angel Token
#AUTO_DEFINE _ANGELTOKEN_ create(Angel:Creature Angel:4/4:white:flying)

# Beast Token
#AUTO_DEFINE _BEASTTOKEN_ create(Beast:Creature Beast:3/3:green)

# Dragon Token
#AUTO_DEFINE _DRAGONTOKEN_ create(Dragon:Creature Dragon:5/5:red:flying)

# Elephant Token
#AUTO_DEFINE _ELEPHANTTOKEN_ create(Elephant:Creature Elephant:3/3:green)

# Goblin Token
#AUTO_DEFINE _GOBLINTOKEN_ create(Goblin:Creature Goblin:1/1:red)

# Insect Token
#AUTO_DEFINE _INSECTTOKEN_ create(Insect:Creature Insect:1/1:green)

# Knight Token
#AUTO_DEFINE _KNIGHTTOKEN_ create(Knight:Creature Knight:2/2:white:vigilance)

# Phyrexian Mite Token
#AUTO_DEFINE _PHYREXIANMITETOKEN_ create(phyrexian mite:artifact creature phyrexian mite:1/1:poisontoxic:cantblock)

# Red Elemental Token
#AUTO_DEFINE _REDELEMENTALTOKEN_ create(Elemental:Creature Elemental:1/1:red)

# Saproling Token
#AUTO_DEFINE _SAPROLINGTOKEN_ create(Saproling:creature Saproling:1/1:green)

# Servo Token
#AUTO_DEFINE _SERVOTOKEN_ create(Servo:Artifact Creature Servo:1/1)

# Soldier Token
#AUTO_DEFINE _SOLDIERTOKEN_ create(soldier:creature soldier:1/1:white)

# Spirit Token
#AUTO_DEFINE _SPIRITTOKEN_ create(Spirit:creature Spirit:1/1:white:flying)

# Thopter Token
#AUTO_DEFINE _THOPTERTOKEN_ create(Thopter:Artifact Creature Thopter:1/1:flying)

# Wolf Token
#AUTO_DEFINE _WOLFTOKEN_ create(Wolf:creature Wolf:2/2:green)

# Zombie Token
#AUTO_DEFINE _ZOMBIETOKEN_ create(zombie:creature zombie:2/2:black)